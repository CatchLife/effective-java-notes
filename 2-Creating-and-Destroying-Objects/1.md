---
prev: ../1-Introduction/0
---

# 1.考虑用静态工厂方法代替构造器

对于类而言，要想获得它的一个实例，最常用的方法就是提供一个公有的构造器。除此之外，还可以提供一个公有的*静态工厂方法*（static factory method），它只是一个返回类实例的静态方法。下面是一个来自`Boolean`的简单示例。这个方法将`boolean`基本类型值转换成了一个`Boolean`的对象引用：

```java
public static Boolean valueOf(boolean b){
  return  b ? Boolean.TRUE : Boolean.FALSE;
}
```

**注意！本节中的静态工厂方法与设计模式中的工厂方法模式不同。**

## 静态工厂方法有以下几大优势

### 它有名称

如果构造器的参数本身没有确切地描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用，产生的客户端代码也更易于阅读。

例如，构造器  `BigInteger(int, int, Random)`返回的  `BigInteger`可能为素数，如果用名为  `BigInteger.probablePrime`的静态工厂方法来表示，显然更为清楚。

### 不必在每次调用它们的时候都创建一个新对象

这使得不可变类（实例不能被修改的类）可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象。`Boolean.valueOf(boolean)`方法说明了这项技术：它从来不创建对象。这种方法类似于  `Flyweight模式`（享元模式）。如果程序经常创建相同的对象，并且创建对象的代价很高，则这项技术可以极大地提升性能。

静态工厂方法能够为重复的调用返回相同的对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称作  *实例受控的类* （instance-controlled）。编写实例受控类有几个原因。实例受控使得类可以确保它是一个  `Singleton`（见第 3 条）或者是不可实例化的（见第 4 条）。它还使得不可变的类（见第 15 条）可以确保不会存在两个相等的实例，即当且仅当  `a==b`的时候才有  `a.equals(b)`为  `true`。如果类保证了这一点，它的客户端就可以使用  `==`操作符来代替`equals(Object)`方法，这样可以提升性能。枚举（ `enum`）类型（见第 30 条）保证了这一点。

这种模式即单例模式中的懒汉模式/饿汉模式（取决于类加载时是否完成初始化创建实例）

### 它们可以返回原返回类型的任何子类型的对象

这样我们在选择返回对象的类时就有了更大的灵活性。比如`java.util.EnumSet`（见第 32 条）没有公有构造器，只有静态工厂方法。它们返回两种实现类之一，具体则取决于底层枚举类型的大小；如果它的元素有 64 个或者更少，就像大多数枚举类型一样，静态工厂方法就会返回一个  `RegularEnumSet`实例，用  `long`进行支持；如果枚举类型有 65 个或者更多元素，工厂就返回  `JumboEnumSet`实例，用  `long`数组进行支持。

### 在创建参数化类型实例的时候，它们使代码变得更加简洁

在调用参数化类的构造器时，即使类型参数很明显，也必须指明。这通常要求你接连两次提供类型参数：

```java
Map<String, List<String>> m =  new  HashMap<String, List<String>>();
```

随着类型参数变得越来越长，越来越复杂，这一冗长的说明也变得痛苦起来。但是有了静态工厂方法，编译器就可以替你找到类型参数。这被称作类型推导（type inference）。例如，假设 `HashMap`提供了这个静态工厂：

```java
public static <K, V> HashMap<K, V> newInstance() {

     return   new  HashMap<K, V>();

}
```

你就可以用下面这句简洁的代码代替上面繁琐的声明：

```java
Map<String, List<String>> m = HashMap.newInstance();
```

## 静态工厂方法有以下几个缺点

### 类如果不含有公有的或者受保护的构造器，就不能被子类化

对于公有的静态工厂所返回的非公有类，也同样如此。它们也不能被实例化。但是这样也许会因祸得福，因为它鼓励程序员使用复合（composition），而不是继承（见第 16 条）

### 它们与其他的静态方法实际上没有任何区别

在 API 文档中，它们没有像构造器那样在 API 文档中明确标识出来，因此，对于提供了静态工厂方法而不是构造器的类来说，要想查明如何实例化一个类，这是非常困难的。下面是静态工厂方法的一些惯用名称：

- `valueOf`—— 不太严格地讲，该方法返回的实例与它的参数具有相同的值。这样的静态工厂方法实际上是类型转化方法。
- `of`—— `valueOf`的一种更为简洁的替代，在 `EnumSet`（见第 32 条）中使用并流行起来。
- `getInstance`—— 返回的实例是通过方法的参数来描述的，但是不能够说与参数具有同样的值。对于 `Singleton`来说，该方法没有参数，并返回唯一的实例。
- `newInstance`—— 像 `getInstance`一样，但 `newInstance`能够确保返回的每个实例都与所有其他实例不同。
- `getType`—— 像 `getInstance`一样，但是在工厂方法处于不同的类中的时候使用。 _Type_ 表示工厂方法所返回的对象类型。
- `newType`—— 像 `newInstance`一样，但是在工厂方法处于不同的类中的时候使用。 _Type_ 表示工厂方法所返回的对象类型。

简而言之，静态工厂方法和公有构造器都各有用处，我们需要理解它们各自的长处。静态工厂通常更加合适，因此切忌第一反应就是提供公有的构造器，而不先考虑静态工厂。
