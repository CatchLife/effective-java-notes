(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{163:function(t,s,a){"use strict";a.r(s);var n=a(0),o=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"_8-覆盖-equals-时请遵守通用约定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-覆盖-equals-时请遵守通用约定","aria-hidden":"true"}},[t._v("#")]),t._v(" 8.覆盖 equals 时请遵守通用约定")]),t._v(" "),a("p",[t._v("以下几种情况不需要覆盖"),a("code",[t._v("equals")]),t._v("方法：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("类的每个实例本质上都是唯一的。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("不关心类是否提供了“逻辑相等（logical equality）”的测试功能。")]),t._v(" 例如，"),a("code",[t._v("java.util.Random")]),t._v("覆盖了"),a("code",[t._v("equals")]),t._v("，以检查两个"),a("code",[t._v("Random")]),t._v("实例是否产生相同的随机数序列，但是设计者并不认为客户端需要或者期望这样的功能。在这样的情况下，从"),a("code",[t._v("Object")]),t._v("继承得到的"),a("code",[t._v("equals")]),t._v("实现已经足够了。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("超类已经覆盖了 equals，从超类继承过来的的行为对于子类也是合适的。")]),t._v(" 例如，大多数的"),a("code",[t._v("Set")]),t._v("实现都从"),a("code",[t._v("AbstractSet")]),t._v("继承"),a("code",[t._v("equals")]),t._v("实现，"),a("code",[t._v("List")]),t._v("实现从"),a("code",[t._v("AbstractList")]),t._v("继承"),a("code",[t._v("equals")]),t._v("实现,"),a("code",[t._v("Map")]),t._v("实现从"),a("code",[t._v("AbstractMap")]),t._v("继承"),a("code",[t._v("equals")]),t._v("实现。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("类是私有的或是包级私有的，可以确定它的 equals 方法永远也不会被调用。")]),t._v(" 在这种情况下，无疑是应该覆盖"),a("code",[t._v("equals")]),t._v("方法的，以防它被意外调用：")])])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n"),a("span",{attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("equals")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Object o"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{attrs:{class:"token class-name"}},[t._v("AssertionError")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{attrs:{class:"token comment"}},[t._v("// Method is never called")]),t._v("\n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("如果类具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且超类还没有覆盖"),a("code",[t._v("equals")]),t._v("以实现期望的行为，这时我们就需要覆盖"),a("code",[t._v("equals")]),t._v("方法。这通常属于“值类（value class）”的情形。")]),t._v(" 有一种“值类”不需要覆盖"),a("code",[t._v("equals")]),t._v("方法，即用实例受控，确保“每个值至多只存在一个对象”的类。")]),t._v(" "),a("p",[t._v("下面是来自"),a("code",[t._v("Object")]),t._v("的"),a("code",[t._v("equals")]),t._v("规范，"),a("code",[t._v("equals")]),t._v("方法实现了"),a("em",[t._v("等价关系（equivalence relation）")]),t._v(" ：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("自反性（reflexive）。")]),t._v(" 对于任何非"),a("code",[t._v("null")]),t._v("的引用值"),a("code",[t._v("x")]),t._v("，"),a("code",[t._v("x.equals(x)")]),t._v("必须返回"),a("code",[t._v("true")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("对称性（symmetric）。")]),t._v(" 对于任何非"),a("code",[t._v("null")]),t._v("的引用值"),a("code",[t._v("x")]),t._v("和"),a("code",[t._v("y")]),t._v("，当且仅当"),a("code",[t._v("y.equals(x)")]),t._v("返回"),a("code",[t._v("true")]),t._v("时，"),a("code",[t._v("x.equals(y)")]),t._v("必须返回"),a("code",[t._v("true")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("传递性（transitive）。")]),t._v(" 对于任何非"),a("code",[t._v("null")]),t._v("的引用值"),a("code",[t._v("x")]),t._v("、"),a("code",[t._v("y")]),t._v("和"),a("code",[t._v("z")]),t._v("。如果"),a("code",[t._v("x.equals(y)")]),t._v("返回"),a("code",[t._v("true")]),t._v("，并且"),a("code",[t._v("y.equals(z)")]),t._v("也返回"),a("code",[t._v("true")]),t._v("，那么"),a("code",[t._v("x.equals(z)")]),t._v("也必须返回"),a("code",[t._v("true")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("一致性（consistent）。")]),t._v(" 对于任何非"),a("code",[t._v("null")]),t._v("的引用值"),a("code",[t._v("x")]),t._v("和"),a("code",[t._v("y")]),t._v("，只要"),a("code",[t._v("equals")]),t._v("的比较操作在对象中所用的信息没有被修改，多次调用"),a("code",[t._v("x.equals(x)")]),t._v("就会一致地返回"),a("code",[t._v("true")]),t._v("，或者一致的返回"),a("code",[t._v("false")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("非空性（Non-nullity）。")]),t._v(" 对于任何非"),a("code",[t._v("null")]),t._v("的引用值"),a("code",[t._v("x")]),t._v("，"),a("code",[t._v("x.equals(null)")]),t._v("必须返回"),a("code",[t._v("false")]),t._v("。")])]),t._v(" "),a("p",[a("strong",[t._v("对于一个继承了父类同时又扩展了自己属性的类，无法同时保证其对称性和传递性。")]),t._v(" 书中原话："),a("strong",[t._v("我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留"),a("code",[t._v("equals")]),t._v("约定。")])]),t._v(" "),a("p",[t._v("针对于此，书中给了一个建议："),a("strong",[t._v("复合优于继承。")]),t._v(" 即不再继承可实例化类，而是把可实例化类作为一个私有的属性，并返回一个 "),a("strong",[t._v("视图")]),t._v(" （view），下面是一个简单的例子，"),a("code",[t._v("ColorPoint")]),t._v("不再继承"),a("code",[t._v("Point")]),t._v("，而是采用复合：")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{attrs:{class:"token comment"}},[t._v("// Adds a value component without violating the equals contract")]),t._v("\n"),a("span",{attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{attrs:{class:"token class-name"}},[t._v("ColorPoint")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("final")]),t._v(" Point point"),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("final")]),t._v(" Color color"),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("ColorPoint")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("int")]),t._v(" y"),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Color color"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("color "),a("span",{attrs:{class:"token operator"}},[t._v("==")]),t._v(" null"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),a("span",{attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{attrs:{class:"token class-name"}},[t._v("NullPointerException")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    point "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{attrs:{class:"token class-name"}},[t._v("Point")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("this")]),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("color "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" color"),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{attrs:{class:"token comment"}},[t._v("/**\n   * Returns the point-view of this color point.\n   */")]),t._v("\n  pulic Point "),a("span",{attrs:{class:"token function"}},[t._v("asPoint")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" point"),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n  "),a("span",{attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("equals")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Object o"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token operator"}},[t._v("!")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o "),a("span",{attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),a("span",{attrs:{class:"token class-name"}},[t._v("ColorPoint")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{attrs:{class:"token boolean"}},[t._v("false")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    ColorPoint cp "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ColorPoint"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" o"),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" cp"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("point"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("equals")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("point"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("&&")]),t._v(" cp"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("color"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("equals")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("color"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),a("span",{attrs:{class:"token comment"}},[t._v("// Remainder omitted")]),t._v("\n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("注意，你可以在一个抽象（abstract）类的子类中增加新的值组件，而不会违反 equals 预定。")]),t._v(" 例如，你可能有一个抽象的 Shape 类，它没有任何值组件，Circle 子类添加了一个 radius 域，Rectangle 子类添加了 length 和 width 域。只要不可能直接创建超类的实例，前面所述的种种问题就都不会发生。")]),t._v(" "),a("p",[t._v("书中给出了实现高质量"),a("code",[t._v("equals")]),t._v("方法的诀窍：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("使用==操作符检查“参数是否为这个对象的引用”。")]),t._v(" 如果是，则返回 true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。")]),t._v(" "),a("li",[a("strong",[t._v("使用 instanceof 操作符检查“参数是否为正确的类型”。")]),t._v(" 如果不是，则返回 false。一般说来，所谓“正确的类型”是指 equals 方法所在的那个类。有些情况下，是指该类所实现的某个接口。如果类实现的接口改进了 equals 约定，允许在实现了该接口的类之间进行比较，那么就使用接口。集合接口（collection interface）如 Set、List、Map 和 Map.Entry 具有这样的特性。")]),t._v(" "),a("li",[a("strong",[t._v("把参数转换成正确的类型。")]),t._v(" 因为转换之前进行过 instanceof 测试，所以确保会成功。")]),t._v(" "),a("li",[a("strong",[t._v("对于该类中每个“关键（significant）域，检查参数中的域是否与该对象中对应的域相匹配”。")]),t._v(" 如果这些测试全部成功，则返回 true；否则返回 false。对于 float 域，可以使用 Float.compare 方法；对于 double 域，则使用 Double.compare。对于 float 和 double 域进行特殊的处理是有必要的，因为存在着 Float.NaN、-0.0f 以及类似的 double 常量；详细信息请参考 Float.equals 的文档。"),a("strong",[t._v("域的比较顺序可能会影响到 equals 方法的性能。为了获得最佳的性能，应该罪行比较最有可能不一致的域，或者是开销最低的域。")])]),t._v(" "),a("li",[a("strong",[t._v("当你编写完成了 equals 方法之后，应该问自己三个问题：它是不是对称的、传递的、一致的？")]),t._v(" 并且不要只是自问，还要编写单元测试来检验这些特性！")])]),t._v(" "),a("p",[t._v("下面是一些告诫：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("覆盖 equals 时总要覆盖 hashCode。")])]),t._v(" "),a("li",[a("strong",[t._v("不要企图让 equals 方法过于智能。")]),t._v(" 如果想过度地去寻求各种等价关系，则很容易陷入麻烦之中。例如，File 类不应该试图把指向同一个文件的符号链接（symbolic link）当作相等的对象来看待。所幸 File 类没有这样做。")]),t._v(" "),a("li",[a("strong",[t._v("不要将 equals 声明中的 Object 对象替换为其他的类型。")]),t._v(" 否则就不是覆写了"),a("code",[t._v("Object.equals")]),t._v("而是重载，可以使用"),a("code",[t._v("@Override")]),t._v("注解进行约束。")])])])}],!1,null,null,null);o.options.__file="8.md";s.default=o.exports}}]);