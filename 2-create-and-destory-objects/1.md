---
prev: ../1-introduction/introduction
---

# 考虑用静态工厂方法代替构造器

对于类而言，要想获得它的一个实例，最常用的方法就是提供一个公有的构造器。除此之外，还可以提供一个公有的*静态工厂方法*（static factory method），它只是一个返回类实例的静态方法。下面是一个来自`Boolean`的简单示例。这个方法将`boolean`基本类型值转换成了一个`Boolean`的对象引用：

```java
public static Boolean valueOf(boolean b){
  return  b ? Boolean.TRUE : Boolean.FALSE;
}
```

**注意！本节中的静态工厂方法与设计模式中的工厂方法模式不同。**

## 1.采用静态工厂方法有以下几大优势：

- **它有名称**

  如果构造器的参数本身没有确切地描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用，产生的客户端代码也更易于阅读。

  例如，构造器 ` BigInteger(int, int, Random)  `返回的 ` BigInteger  `可能为素数，如果用名为 ` BigInteger.probablePrime  `的静态工厂方法来表示，显然更为清楚。

- **不必在每次调用它们的时候都创建一个新对象**

  这使得不可变类（实例不能被修改的类）可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象。`Boolean.valueOf(boolean)  `方法说明了这项技术：它从来不创建对象。这种方法类似于 ` Flyweight模式  `（享元模式）。如果程序经常创建相同的对象，并且创建对象的代价很高，则这项技术可以极大地提升性能。

  静态工厂方法能够为重复的调用返回相同的对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称作 *实例受控的类* （instance-controlled）。编写实例受控类有几个原因。实例受控使得类可以确保它是一个 ` Singleton `（见第3条）或者是不可实例化的（见第4条）。它还使得不可变的类（见第15条）可以确保不会存在两个相等的实例，即当且仅当 ` a==b  `的时候才有 ` a.equals(b)  `为 ` true  `。如果类保证了这一点，它的客户端就可以使用 ` ==  `操作符来代替` equals(Object)  `方法，这样可以提升性能。枚举（ ` enum  `）类型（见第30条）保证了这一点。

- **它们可以返回原返回类型的任何子类型的对象**

  这样我们在选择返回对象的类时就有了更大的灵活性。